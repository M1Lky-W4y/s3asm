#!/usr/bin/env python

from __future__ import print_function

import sys, os, collections

def hex_str(s):
    ret = ''.join("%02x" % c for c in s).lstrip('0')
    if len(ret) == 0: ret = '0'
    return '$' + ret

def print_data(mnemonic,size):
    def f(dass,s,a=0):
        import cStringIO
        sio = cStringIO.StringIO(s)
        buf = bytearray(sio.read(size))
        addr = a
        while len(buf) == size:
            dass[addr]=('',mnemonic,hex_str(buf),buf,'')
            addr += size
            buf = bytearray(sio.read(size))
        if len(buf) != 0:
            raise Exception("%d bytes not handled near address %x" %
                            (len(buf),addr))
        return addr
    return f

def print_string(mnemonic):
    def f(dass,s,a=0):
        addr = a
        for nul_s in s.split('\0'):
            size = len(nul_s)+1
            s_repl = "'"
            for c in nul_s:
                if c in ['\n', '\t', "'", ]:
                    s_repl += "',%d,'"%ord(c)
                else:
                    s_repl += c
            s_repl += "',0"
            dass[addr] = ('',mnemonic,s_repl,bytearray(),'')
            addr += size
        return addr
    return f
        
long   = print_data('dc.l',4)
short  = print_data('dc.w',2)
byte   = print_data('dc.b',1)
string = print_string('dc.b')

def dasm_pass(dass,segments,code,args):
    mnemonic_cutsuffix = [
        "bchg.b", "bset.b", "btst.b", "bclr.b",
        ]
    
    if args.verbose: print("Starting disassembling pass",file=sys.stderr)
    
    from capstone import Cs, CS_ARCH_M68K, CS_MODE_M68K_000

    md = Cs(CS_ARCH_M68K, CS_MODE_M68K_000)
    if args.keep_going:
        if args.verbose: print("Enabling SKIPDATA mode",file=sys.stderr)
        md.skipdata = True
        md.skipdata_setup = ("dc.w", None, None)
        import re
        skipdata_re = re.compile(r'0x[0-9a-f]{2}, 0x[0-9a-f]{2}')
        
    for iseg, seg in enumerate(segments):
        n,off,f = seg
        nextoff = -1
        if iseg == len(segments)-1:
            # last segment
            segment = code[off:]
        else:
            nextoff = segments[iseg+1][1]
            segment = code[off:nextoff]
        if args.verbose: print("Starting segment %d at offset 0x%x, length %d"%
                               (iseg,off,len(segment)),file=sys.stderr)
        if n.startswith("code"):
            next_address = off
            for i in md.disasm(segment,off):
                if md.skipdata and re.match(skipdata_re,i.op_str):
                    op = hex_str(i.bytes)
                else:
                    op = i.op_str.replace(', ',',').replace('.l','')
                if i.mnemonic in mnemonic_cutsuffix:
                    mne = i.mnemonic[:-2]
                else:
                    mne = i.mnemonic
                dass[i.address]=(
                    '',          # label
                    mne,         # mnemonic
                    op,          # operands
                    i.bytes,     # raw bytes
                    '',          # remarks
                )
                next_address = int(i.address+i.size)
            if (nextoff > 0 and next_address != nextoff) or \
               (nextoff < 0 and next_address != len(code)):
                print("Code segment:",end=" ",file=sys.stderr)
                print("Stopping early at global offset 0x%x,"
                      " segment offset 0x%x" %
                      (next_address,next_address-off),file=sys.stderr)
                data = ' '.join("%02x" % ord(c)
                                for c in code[next_address:next_address+4])
                print("Next 4 bytes: %s" % data,file=sys.stderr)
                break
        else:
            offset = f(dass,segment,off)
            if nextoff > 0 and offset < nextoff:
                print("Data segment:",end=" ",file=sys.stderr)
                print("Stopping early at global offset 0x%x,"
                      " segment offset 0x%x" %
                      (offset,offset-off),file=sys.stderr)
    if args.verbose: print("Finished disassembling pass",file=sys.stderr)
 

def label_pass(dass,args):
    if args.verbose: print("Starting labeling pass",file=sys.stderr)
    lab_counter = 0
    for addr in dass.iterkeys():
        lab, mne, op, ba, rem = dass[addr]
        addlabel = False
        for m in [ 'dbeq', 'dbne', 'dbra', 'bra', 'bne', 'beq', 'blt', 'bsr',
                   'bcs', 'bmi', 'bge', 'ble', 'bgt', 'bhi', 'bls', 'bcc',
                   'bvc', 'bpl', 'dbmi', 'dbpl', 'dbge', 'dblt' ]:
            if mne.startswith(m):
                addlabel = True
                break
        if addlabel:
            i = op.find('#$')
            if i != -1:
                a = int(op[i+2:],16)
                if not dass.has_key(a):
                    print("WARNING: address 0x%x not in disassembly (yet)" %
                          a,file=sys.stderr)
                    dass[addr] = (lab, mne, op, ba, "Check branch address")
                    continue
                labelpos = dass[a]
                labstr = labelpos[0]
                if not len(labstr):
                    labstr  = "lab_%d" % lab_counter
                    if a != addr:
                        dass[a] = (labstr,labelpos[1],labelpos[2],
                                   labelpos[3],labelpos[4])
                    lab_counter += 1
                op = op[:i]+labstr
                if a == addr: lab = labstr
                dass[addr] = (lab,mne,op,ba,rem)
                #print("Label %s address 0x%x" % (labstr,a),file=sys.stderr)
    if args.verbose: print("Finished labeling pass",file=sys.stderr)
    
def output_pass(dass,segments,args):
    if args.verbose: print("Starting output pass",file=sys.stderr)
    output = sys.stdout
    if args.outfile: output = open(args.outfile,'w')
        
    seg_counter = 0
    n,off,f =  segments[seg_counter]
    seg_counter += 1
    print(";",file=output)
    print("; %s" % n,file=output)
    nextoff = -1 if len(segments) == seg_counter else segments[seg_counter][1]
    for addr,data in dass.items():
        lab, mne, op, ba, rem = data
        if nextoff > 0 and addr >= nextoff:
            n,off,f =  segments[seg_counter]
            seg_counter += 1
            print(";",file=output)
            print("; %s" % n,file=output)
            nextoff = -1 if len(segments) == seg_counter else segments[seg_counter][1]
        raw = ' '.join("%02x" % b for b in ba)
        print("%s\t%s\t%s\t; 0x%x  (%s) %s" %
              (lab.ljust(10),mne,op.ljust(20),addr,raw,rem),file=output)
    if args.verbose: print("Finished output pass",file=sys.stderr)
    if args.outfile: output.close()

def read_control(control):
    if not os.path.exists(control):
        print("Control file '%s' does not exist" % control, file=sys.stderr)
        sys.exit(1)
    segments = []
    with open(control,'r') as f:
        for l in f:
            l = l.strip()
            if l.startswith('#') or l.startswith(';'): continue
            cols = l.split()
            name, offset, action = '', 0, None
            if len(cols) > 0:
                name = str(cols[0])
            if len(cols) > 1:
                base = 10
                if cols[1].startswith('0x'): base=16
                offset = int(cols[1],base)
            if len(cols) > 2:
                action = eval(cols[2])
            segments.append((name,offset,action))
    return segments

def read_input(infile):
    if infile == '-':
        code = sys.stdin.read()
    else:
        if not os.path.exists(infile):
            print("Input file '%s' does not exist" % infile, file=sys.stderr)
            sys.exit(1)
        with open(infile,'rb') as f:
            code = f.read()
    return code
    
def dasm(args):
    inputfn = args.input[0]
    code = read_input(inputfn)
    if args.verbose:
        print("Read %d bytes from '%s'" % (len(code),inputfn),
              file=sys.stderr)
            
    dass = collections.OrderedDict()

    autocontrol = inputfn+'.txt'
    if args.control:
        segments = read_control(args.control)
    elif not args.no_auto and os.path.exists(autocontrol):
        if args.verbose:
            print("Automatically using control file '%s'" % autocontrol,
                  file=sys.stderr)
        segments = read_control(autocontrol)
    else:
        segments = [("code",0,None)]
    if args.verbose:
        print("Found %d segment(s)" % len(segments), file=sys.stderr)

    # disassemble pass
    dasm_pass(dass,segments,code,args)
    
    # label pass
    if args.label: label_pass(dass,args)
    
    # output pass
    output_pass(dass,segments,args)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--control", type=str,
                        help="control file")
    parser.add_argument("-k", "--keep-going", action='store_true',
                        help="don't stop on invalid instructions")
    parser.add_argument("-l", "--label", action='store_true',
                        help="replace constant branch addresses by labels")
    parser.add_argument("-n", "--no-auto", action='store_true',
                        help="do not automatically use matching control file")
    parser.add_argument("-o", "--outfile", type=str,
                        help="write to output to file")
    parser.add_argument("-v", "--verbose", action='store_true',
                        help="print verbose output")
    parser.add_argument("input", type=str, nargs=1,
                        help="name of input file or '-' for stdin")
    args = parser.parse_args()
    dasm(args)
